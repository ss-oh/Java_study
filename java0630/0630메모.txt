정적 변수
- 공용된 정보를 객체와 함께 사용
  개수 목적으로 사용
- 상수 설정 ( ex. Math.PI )
- 리소스 공유 
   객체를 따로 생성하지 않고 관리하므로 메모리 관리에 효율적
- 유틸리티 클래스를 만들때 사용

=============================

참조
- 내용에 의한 참조 ( call by value )
- 주소에 의한 참조 ( call by reference )

=========================

264p. 접근제한자
public
패키지, 클래스 상관없이 어디서든 접근 허용
protected
같은 패키지만 접근 허용
만약 다른 패키지에서 접근하려면 상속관계여야 한다
default
동일한 패키지만 접근 허용
보통 접근제한자가 생략되어있으면 default임
private
다른 패키지, 클래스는 접근 불가능
해당 클래스에서만 접근 허용

==================================

캡슐화 - private을 사용하는 이유
외부 접근을 제한 은닉

객체 내부 변수들을 외부에서 직접 변경을 못하게 막음
대신 클래스 메서드를 통해 접근제어를 함

유효성 검사 - 잘못된 값이 들어가지 않도록 설정
                   초기 설정 이후 값을 변경 못하도록
유연성 - 나중에 유지보수 시 구조 변경하더라도 외부 코드는 영향을 적게 받음

======================
싱글톤 275p.
디자인 패턴 : 많이 사용하는 다양한 코드들 있는데
                  보다 효율적으로 작성 가능한 틀

싱글톤 패턴
- 단 하나의 객체만 생성되는 클래스
자원 관리가 효율적임
전역적으로 접근 허용

자바와 DB연결하는 클래스를 생성
A클래스에서 DB연결 작업을 하고싶음 -> DB연결 클래스 객체 생성
B클래스에서 DB연결 작업을 하고싶음 -> DB연결 클래스 객체 생성



static는 클래스가 초기화 될때 단한번 생성

초기화 되는 순간
new 키워드로 객체를 생성할 때
static 메서드나 static 변수를 접근할 때

===================

상속
부모 클래스에 있는 모든것을 물려받음
상속을 하면 코드의 재사용성이 높아지고, 비슷한 클래스를 쉽고 빠르게 구현 가능
단, 상속은 하나의 클래스로만 받을 수 있다 ( 다중 상속 불가능 )
상속받은 자식 클래스는 다른 클래스의 부모가 될 수 있음
자식 클래스는 기능 추가가 가능 함
모든 클래스는 기본적으로 Object클래스를 상속받음


부모에게 물려받은 메서드를 다르게 처리하고 싶을 때
메서드 오버라이딩( 메서드 재정의 )

새로운 메서드를 만든다기보다
상속받은 메서드의 이름과 매개변수, 리턴이 모두 동일하고
내부 코드만 변경

오버로딩
이름은 같지만 선언부가 다름( 반환타입, 매개변수 타입, 매개변수 타입의 순서 )

오버라이딩
상속 관계에서 부모클래스의 메서드를 자식클래스에서 재정의
- 부모 클래스의 메서드 선언부와 동일해야 한다 ( 매개변수, 반환타입이 일치 )
  단, 반환타입은 부모에 설정된 반환타입으로 변환가능하면 가능함( 자동 형변환이 되면 가능 )
- 부모클래스의 접근제한자의 범위보다 더 좁으면 안됨
- final키워드로 선언된 경우 불가능
- 부모클래스의 메서드 접근제한자가 private이면 불가능
- 부모클래스의 메서드가 static메서드일 경우 불가능


클래스나 메서드에 final이 붙으면
클래스의 경우 상속이 불가능( 부모가 될 수 없음 )
메서드의 경우 오버라이딩이 불가능




=======================

형 변환  307p.

자동 형변환 ( ex  int -> double ) : 작은거에서 큰거로 넣을때 자동으로 됨
명시적 형변환 ( ex double -> int ) : (자료형) a   큰거에서 작은거로는 반드시 명시

=================

다형성 => 타입이 같지만 실행결과가 다양한 객체로 이용할 수 있는 성질

모든 자식클래스는 부모클래스로 타입변환이 가능
부모타입인 변수들에는 모든 자식객체들이 들어갈 수 있다 ( 자동형변환, 업캐스팅 )
animalList[0] = (Animal) new Human();

하지만 해당 객체의 메서드나 멤버변수는 부모타입인 형태로 사용이 불가능
오버라이딩된 메서드나, 상속받은 변수는 제외

그래서 해당 타입으로 다시 변환을 해야 사용이 가능함
- Human 객체가 Animal로 변환되서 저장되어있는 상태
- Human클래스의 기능들을 사용하고 싶으면 다시 Animal타입이던걸 Human타입으로 변환
- 명시적 형변환(다운캐스팅)해서 타입 변환 후 사용 가능

instanceof 사용을 왜?
현재 배열에는 타입은 동일하지만 다양한 형태의 객체들이 들어 있음

다양한 형태들마다 실제 호출되는 메서드가 다름
그래서 정확하게 해당 타입을 검사 후 정확한 타입으로 형변환(다운캐스팅)을 해야하므로 사용

다운캐스팅은 실제 타입이 자식 타입이여만 가능
( Animal로 생성된 객체 -> Human, Tiger, Dog로는 변환 못함 )





































